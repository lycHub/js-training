> this可以在js中的任何地方访问到，比如在一对script标签中直接打印：

    <script>
	    console.log(this); // window
    </script>

全局下的this当然指向window，所以我们更多讨论的是函数中的this指向。

判断函数中的this指向，有个基本规则：**谁调用的函数，this就指向谁**，下面围绕这句话，归纳下函数的各种调用场景。

**一、直接调用**
```javascript
 function  test() {
   console.log(this);  // window
 }
 
 test();   // 同 window.test();
```
直接调用可以看成是在window下调用，符合上述规则
&nbsp;
&nbsp;
&nbsp;


**二、作为对象的属性**
```javascript
   const obj = {
    name: 'aaa',
    printName() {
      console.log(this.name); // aaa
      console.log(this === obj); // true
    }
  }
  obj.printName();
```
obj调用printName方法，这种是最符合上述规则的情况
&nbsp;
&nbsp;
&nbsp;

**三、函数作为参数**
```javascript
   function test(fn) {
        fn();
   }
   const obj = {
     name: 'aaa',
     test() {
       console.log(this); // window
     }
   }
   test(obj.test);
```
test接受一个函数作为参数，然后在内部 **直接调用**，这种情况和第一种直接调用是一样的
&nbsp;
&nbsp;
&nbsp;

**四、new 一个函数**
```javascript
  function fn() {
    console.log(this);
  }
  const test = new fn();  // fn
```
这个情况比较特殊，new 是js中的一个关键字，这个关键字专门用来新建对象，上面new fn()，通常被叫做实例化一个构造函数，构造函数内部的this指向函数本身，并且最后会将this return出去, 具体参考[构造函数](构造函数)

&nbsp;
&nbsp;
&nbsp;

**五、事件函数**
```javascript
  const h1 = document.getElementsByTagName('h1')[0];
  h1.addEventListener('click', function (evt) {
    console.log(this);  // h1节点
    console.log(this === evt.target); // true
  });
```
事件函数中的this指向绑定的element节点，如果换成h1.onclick就更好理解了，可以看成是h1节点调用了onclick方法，符合上述规则


&nbsp;
&nbsp;
&nbsp;

**六、定时器函数**
```javascript
   setTimeout(function () {
    console.log(this);  // window
  }, 200);
```
定时器中的函数自执行，也可以看成是在全局下直接调用的，同情况一

&nbsp;
&nbsp;
&nbsp;

**七、箭头函数**
```javascript
   var name = 'win';
   const obj = {
    name: 'aaa',
    printName: () => {
      console.log('this :', this);  // window
      console.log(this.name); // win
      console.log(this === obj); // false
    }
  }
  obj.printName();
```
上面改造了下情况二的例子，将printName改成了箭头函数，这是printName里的this指向window, 箭头函数的特性：**函数中的this指向函数所处的作用域（注意在es6以前，js只有函数作用域，没有块级作用域）**

所以printName虽然是obj的一个属性，但是obj并不能创造一个封闭空间，仍处于全局作用域中，所以printName里的this指向window。


再结合构造函数看个例子：
```javascript
function Fn() {
  setTimeout(function(){
    console.log(this);  // window
  }, 2000);
  setTimeout(() => {
    console.log(this);  // Fn
  }, 2000);
}
new Fn();
```
按照第六种情况，定时器函数中的this，指向window。
如果改为箭头函数，箭头函数中的this指向函数所处的作用域，因为老js只有函数才能形成一个封闭的作用域，也就是说构造函数Fn内部是个小的作用域，this指向Fn