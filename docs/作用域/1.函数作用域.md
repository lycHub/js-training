**老的js(es6以前)没有块级作用域，只能用函数来冒充块级作用域**
> {}大括号之间的区域就叫做块级作用域

    <script>
	    console.log(this); // window
    </script>

全局下的this当然指向window，所以我们更多讨论的是函数中的this指向。

判断函数中的this指向，有个基本规则：**谁调用的函数，this就指向谁**，下面围绕这句话，归纳下函数的各种调用场景。

**一、js没有块级作用域，只有函数作用域**
```javascript
   if(true){
    var a = 'a';
  }
  function fn() {
    var b = 'b';
  }
  console.log(a); // a
  console.log(b); // b is not defined
```

**二、变量提升**
<br />
稍微改下上面的代码：
```javascript
   if(true){
    const a = 'a';
  }
  
  console.log(a); // a is not defined
```

把var改成const后，a就访问不到了，也就是说，js其实是有块级作用域的？
其实这和开头的概念不矛盾，说js没有跨级作用域，这是es6出现前的概念，**其实本质是因为var声明的变量会提升到当前作用域的最顶级，上面最顶级的作用域当然就是window了。**

也就是说，用var声明的变量其实是如下过程：
```javascript
  var a;      // 变量提升到了最顶级
  if(true){
    a = 'a';    // 赋值
  }
  
  console.log(a); // a
```


再看个更直观的例子：
```javascript
  console.log(a); // undefined
  var a = 'a';
```

上面先打印，再声明变量，结果输出undefined，说好的变量提升呢？
js稍微好点的同学可能会觉的这个输出结果不太对，我们来直接输出一下a:
```javascript
  console.log(a); // a is not defined
```
这才是正确的结果，上个例子只输出undefined只是说a没有值，并不是a不存在，实际过程是这样的：
```javascript
  var a;          // 变量提升
  console.log(a); // undefined
  a = 'a';
```
<br /><br /><br />

**三、顶级作用域**
<br />
刚才的变量都是提升到了最顶级的window，现在看下函数中的变量会提升到哪去。
```javascript
  var a = 'a';
  function fn(){
    console.log(a); // a
  }
  fn();
```
上面打印出 'a' 毫无悬念

```javascript
  var a = 'a';
  function fn(){
    console.log(a); // undefined
    var a = 'b';
  }
  fn();
```
这是a打印出undefined。

```javascript
  var a = 'a';
  function fn(){
    a = 'c';
    console.log(a); // c
    var a = 'b';
  }
  fn();
```

在函数中，var声明的变量会提升到函数最顶部，其过程是：
```javascript
  var a = 'a';
  function fn(){
    var a;
    a = 'c';
    console.log(a); // c
    a = 'b';
  }
  fn();
  ```

  <br /><br /><br />

**四、函数表达式**
<br />
>有个概念说什么，变量能提升，函数表达式不能提升，提出这个概念的人我认为居心不良，有故意增加js学习难度的嫌疑
先不用管这个概念，看下面这段代码：
```javascript
console.log(fn);    // undefined
  fn();   // fn is not a function
  var fn = function(){
    console.log('f');
  }
```
根据前面讲的，var声明的变量会提升，所以fn是undefined，调用fn，当然会报错了，这就是所谓的函数表达式不能提升？？？  i fu le;