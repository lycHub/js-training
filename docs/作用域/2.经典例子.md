这里有5个li标签，要求点击每个li输出索引。
```html
<ul>
  <li>aaaaaa</li>
  <li>bbbbb</li>
  <li>ccccc</li>
  <li>ddddd</li>
  <li>eeeee</li>
</ul>
```

<br /><br /><br />
**一、for循环**
```javascript
  const lis = document.getElementsByTagName('li');
  for (var a = 0; a < lis.length; a++) {
    lis[a].addEventListener('click', function () {
      console.log(a); // 全是5
    });
  }
```
这里有两点需要注意：
- var声明的变量会提升
- 事件是异步的

因为上述两点，所以点击的每个li输出都是5，真实过程如下：
```javascript
var a;    // 变量提升
const lis = document.getElementsByTagName('li');
for (a = 0; a < lis.length; a++) {    // 每次循环都覆盖a
  lis[a].addEventListener('click', function () {
    console.log(a); // 全是5
  });
}
// 循环结束后a已经被覆盖成了5
```

<br /><br /><br />
**二、使用let**
<br />
之前讲过const声明的变量不会提升，其实let也一样：
```javascript
const lis = document.getElementsByTagName('li');
for (let a = 0; a < lis.length; a++) {
  lis[a].addEventListener('click', function () {
    console.log(a); // 索引输出正常
  });
}
```

由于变量不会提升，可以理解为声明了5个a变量分别储存了起来


<br /><br /><br />

**三、给li添加属性**
```javascript
const lis = document.getElementsByTagName('li');
for (var a = 0; a < lis.length; a++) {
  lis[a].index = a;
  lis[a].addEventListener('click', function () {
    console.log(this.index);  // 索引输出正常
  });
}
```
<br /><br /><br />

**四、抽出一个方法**
```javascript
const lis = document.getElementsByTagName('li');
for (a = 0; a < lis.length; a++) {
  showIndex(a);
}
function showIndex(i) {
  lis[i].addEventListener('click', function () {
    console.log(i); // 索引输出正常
  });
}
```
函数是由作用域的，这个情况类似二。

<br /><br /><br />

**五、写成闭包**
```javascript
const lis = document.getElementsByTagName('li');
for (a = 0; a < lis.length; a++) {
  (function (i) {
    lis[i].addEventListener('click', function () {
      console.log(i); // 正常
    })
  })(a);
}
```
闭包写法跟 四 是一样的，只是一个把函数写在了for外面，一个写在了里面