**一、多次实例化带来的问题**

```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
  this.sayHi = function() {
    console.log('hi' + this.name);
  }
}

const dema = new Hero('德玛');
dema.sayHi();       // hi德玛

const datou = new Hero('大头');
datou.sayHi();       // hi大头
```

上面Hero函数实例化了两个对象，两个对象都能调用sayHi函数，这很正常，但是仔细看下构造函数会发现，每个英雄除了有不同的属性或方法外（比如每个英雄的名字，年龄都不同），还可能存在相同的属性或方法，**没实例化一次，构造函数就会调用一次，并且会对函数中的每个成员开辟一个储存空间**

```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
  this.sayHi = function() {
    console.log('hi' + this.name);
  }
}

const dema = new Hero('德玛');
const datou = new Hero('大头');

console.log(dema.sayHi === datou.sayHi);  // false
```

可以看到，虽然sayHi方法是长的一样，每个实例化出来的英雄都会有，但是他们并不相等，也就是说，sayHi方法占了两个内存空间，像这种每个实例都会有的共同属性或方法，站这么多空间显然是不合适，所以下面就用到原型来解决这个问题。

&nbsp;
&nbsp;
&nbsp;

**二、原型对象**
**每个引用类型(对象、数组、函数)都自带一个原型属性，名为prototype，值为一个对象，每个实例都能访问到 prototype属性下的成员**
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛');
dema.sayHi();   // hi德玛
```
现在把这个公共的方法sayHi挂在了原型属性上，实例照样能访问到这个方法，那么多个实例话是否还会有上述占内存的问题呢？
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛');
const datou = new Hero('大头');

console.log(dema.sayHi === datou.sayHi);  // true
```
可以看到现在两个实例的sayHi方法是相等的，说明sayHi只占一份内存，这也符合日常规律。

&nbsp;
&nbsp;
&nbsp;

**三、原型对象的思考**
当访问某对象下的成员时，那个成员肯定是挂在对象上的：
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛', 19);
console.log(dema.age);      // 19
dema.sayHi();               // hi德玛
```
上面实例化了一次Hero并赋给变量dema，dema都访问到age很正常，因为age明显是挂在this上的，但是为什么dema能访问到挂在原型上的方法呢，可以打印一下dema, 结果如下：
![image.png](../imgs/2-2-1.png)