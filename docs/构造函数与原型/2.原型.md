**一、多次实例化带来的问题**

```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
  this.sayHi = function() {
    console.log('hi' + this.name);
  }
}

const dema = new Hero('德玛');
dema.sayHi();       // hi德玛

const datou = new Hero('大头');
datou.sayHi();       // hi大头
```

上面Hero函数实例化了两个对象，两个对象都能调用sayHi函数，这很正常，但是仔细看下构造函数会发现，每个英雄除了有不同的属性或方法外（比如每个英雄的名字，年龄都不同），还可能存在相同的属性或方法，**没实例化一次，构造函数就会调用一次，并且会对函数中的每个成员开辟一个储存空间**

```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
  this.sayHi = function() {
    console.log('hi' + this.name);
  }
}

const dema = new Hero('德玛');
const datou = new Hero('大头');

console.log(dema.sayHi === datou.sayHi);  // false
```

可以看到，虽然sayHi方法是长的一样，每个实例化出来的英雄都会有，但是他们并不相等，也就是说，sayHi方法占了两个内存空间，像这种每个实例都会有的共同属性或方法，站这么多空间显然是不合适，所以下面就用到原型来解决这个问题。

&nbsp;
&nbsp;
&nbsp;

**二、原型对象**
**每个引用类型(对象、数组、函数)都自带一个原型属性，名为prototype，值为一个对象，每个实例都能访问到 prototype属性下的成员**
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛');
dema.sayHi();   // hi德玛
```
现在把这个公共的方法sayHi挂在了原型属性上，实例照样能访问到这个方法，那么多个实例话是否还会有上述占内存的问题呢？
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛');
const datou = new Hero('大头');

console.log(dema.sayHi === datou.sayHi);  // true
```
可以看到现在两个实例的sayHi方法是相等的，说明sayHi只占一份内存，这也符合日常规律。

&nbsp;
&nbsp;
&nbsp;

**三、原型对象的思考**
当访问某对象下的成员时，那个成员肯定是挂在对象上的：
```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛', 19);
console.log(dema.age);      // 19
dema.sayHi();               // hi德玛
```
上面实例化了一次Hero并赋给变量dema，dema都访问到age很正常，因为age明显是挂在this上的，但是为什么dema能访问到挂在原型上的方法呢，可以打印一下dema, 结果如下：
<br /><br /><br />
![image.png](../../imgs/2-2-1.png)
<br /><br /><br />
一眼看过去似乎没有sayHi方法，但是仔细看下，在最后还有个__proto__的属性，也是个对象，展开如下：
<br /><br /><br />
![image.png](../../imgs/2-2-2.png)
<br /><br /><br />
可以看到__proto__属性上有sayHi方法，那我们应该也能用dema.__proto__.sayHi()的方式调用吧：

```javascript
function Hero(name, age, skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

Hero.prototype.sayHi = function() {
  console.log('hi' + this.name);
}
const dema = new Hero('德玛', 19);
dema.__proto__.sayHi();   // hiundefined
```

很明显dema.__proto__也能调用到sayHi方法，只是无法取到this.name。
**之前说过，函数中的this却决于是谁调用的，dema.sayHi()，this指向dema，dema.__proto__.sayHi()，this指向dema.__proto__。**

> tip: 可以通过dema.__proto__.sayHi.call(dema);改变this指向

**总结一下：当实例化一个构造函数时，构造函数.prototype会自动赋值给实例.__proto__属性，也就是 dema.__proto__ = Hero.prototype会自动赋值给实例**
所以实例是能访问到原型对象上的成员, 即：dema.__proto__ === Hero.prototype

然后在仔细看下Hero.prototype里的成员，还会发现有个constructor属性，这个属性的值就是Hero本身,
即：Hero.prototype.constructor === Hero
理解到这里，可以画出原型链的第一节示意图：
![image.png](../../imgs/2-2-3.png)


